//
//  EditMyProfileViewController.swift
//  CoPro
//
//  Created by Î∞ïÏã†ÏòÅ on 2/2/24.
//

import UIKit
import SnapKit
import Then
import KeychainSwift

protocol NowProfileUpdateDelegate: AnyObject {
    func didUpdateProfile()
}

class EditMyProfileViewController: BaseViewController, UITextFieldDelegate {
   
   enum EditMyProfileViewType {
      case FirstLogin, NotFirstLogin
   }
   var activeViewType: EditMyProfileViewType = .NotFirstLogin
   private let keychain = KeychainSwift()
   weak var profileUpdateDelegate: NowProfileUpdateDelegate?
   
   var loginVC = LoginViewController()
   var beforeEditMyProfileData: MyProfileDataModel?
   let container = UIView()
   var languageStackView: UIStackView?
   var careerStackView: UIStackView?
   var initialUserName: String?
   var isJobsButtonTap: Bool?
   var editFlag: Bool?
   var nickNameDuplicateFlag: Bool = true
   var selectedJob: String?
   var selectedLanguageButtons = [UIButton]()
   var selectedCareer: String?
   var isNicknameModificationSuccessful: Bool?
   var isFirstLogin: Bool?
   var readyForNextButton: Bool?
   var nicknameValidity: Bool?
   
   var editMyProfileBody = EditMyProfileRequestBody()
   
   
   private let nickNameLabel = UILabel().then({
      $0.setPretendardFont(text: "ÎãâÎÑ§ÏûÑ", size: 17, weight: .bold, letterSpacing: 1.23)
      $0.textColor = UIColor.Black()
   })
   
   private var nicknameDuplicateCheckLabel = UILabel().then {
      $0.setPretendardFont(text: "ÏÇ¨Ïö© Í∞ÄÎä•Ìïú ÎãâÎÑ§ÏûÑÏûÖÎãàÎã§.", size: 11, weight: .regular, letterSpacing: 1.23)
      $0.textColor = UIColor.P1()
   }
   
   let nickNameTextField = UITextField().then {
      $0.placeholder = "ÎãâÎÑ§ÏûÑ"
      $0.clearButtonMode = .always
      $0.keyboardType = .default
      $0.autocapitalizationType = .none
      $0.spellCheckingType = .no
   }
   
   let textFieldContainer = UIView().then {
      $0.layer.backgroundColor = UIColor.G1().cgColor
      $0.layer.cornerRadius = 10
   }
   
   private let languageUsedLabel = UILabel().then {
      $0.setPretendardFont(text: "ÏÇ¨Ïö© Ïñ∏Ïñ¥", size: 17, weight: .bold, letterSpacing: 1.23)
      $0.textColor = UIColor.Black()
   }
   
   private let myJobLabel = UILabel().then {
      $0.setPretendardFont(text: "ÎÇòÏùò ÏßÅÎ¨¥", size: 17, weight: .bold, letterSpacing: 1.23)
      $0.textColor = UIColor.Black()
   }
   
   private let careerLabel = UILabel().then {
      $0.setPretendardFont(text: "Í∞úÎ∞ú Í≤ΩÎ†•", size: 17, weight: .bold, letterSpacing: 1.23)
      $0.textColor = UIColor.Black()
   }
   
   lazy var jobButtonsStackView = UIStackView().then { stackView in
      stackView.axis = .horizontal
      stackView.distribution = .fillEqually
      stackView.spacing = 11
      let buttonTitles = ["Frontend", "Backend", "Mobile", "AI"]
      
      
      for job in buttonTitles {
         stackView.addArrangedSubview(createButton(withTitle: job))
      }
   }
   
   lazy var nextButton = UIButton().then {
      $0.layer.backgroundColor = UIColor.G1().cgColor
      $0.layer.cornerRadius = 10
      $0.addTarget(self, action: #selector(didNextButtonAlert), for: .touchUpInside)
      $0.setTitle("Îã§Ïùå", for: .normal)
      $0.titleLabel?.setPretendardFont(text: "Îã§Ïùå", size: 17, weight: .bold, letterSpacing: 1.23)
      $0.titleLabel?.textColor = UIColor.White()
   }
   
   lazy var doneButton = UIButton().then {
      $0.layer.backgroundColor = UIColor.G1().cgColor
      $0.layer.cornerRadius = 10
      $0.addTarget(self, action: #selector(didDoneButton), for: .touchUpInside)
      $0.setTitle("ÏÑ†ÌÉù ÏôÑÎ£å", for: .normal)
      $0.titleLabel?.setPretendardFont(text: "ÏÑ†ÌÉù ÏôÑÎ£å", size: 17, weight: .bold, letterSpacing: 1.23)
      $0.titleLabel?.textColor = UIColor.White()
      $0.isEnabled = false
   }
   
   private lazy var languageCount = UILabel().then {
      $0.setPretendardFont(text: "(\(selectedLanguageButtons.count)/2)", size: 11, weight: .regular, letterSpacing: 1.23)
      $0.textColor = UIColor.P1()
   }
   
   
   
   
   override func viewDidLoad() {
      super.viewDidLoad()
      view.backgroundColor = UIColor.White()
      nickNameTextField.delegate = self
      nickNameTextField.text = beforeEditMyProfileData?.nickName
      isJobsButtonTap = false
      updateButtonState(type: "First")
      nickNameDuplicateFlag = true
      nicknameValidity = true
      editFlag = true
      
   }
   
   override func setUI() {
      if let sheetPresentationController = sheetPresentationController {
         sheetPresentationController.preferredCornerRadius = 15
         sheetPresentationController.prefersGrabberVisible = true
         sheetPresentationController.detents = [.custom {context in
            return self.returnEditMyProfileUIHeight(type: "First")
         }]
      }
   }
   
   override func setLayout() {
      view.addSubview(container)
      container.addSubviews(nickNameLabel, textFieldContainer, nicknameDuplicateCheckLabel, myJobLabel, jobButtonsStackView, nextButton)
      textFieldContainer.addSubview(nickNameTextField)
      
      container.snp.makeConstraints {
         $0.leading.equalToSuperview().offset(16)
         $0.trailing.equalToSuperview().offset(-16)
         $0.top.equalToSuperview().offset(24)
         $0.bottom.equalToSuperview().offset(-30)
      }
      
      nickNameLabel.snp.makeConstraints {
         $0.top.equalToSuperview()
         $0.leading.equalToSuperview().offset(8)
         $0.height.equalTo(21)
      }
      
      textFieldContainer.snp.makeConstraints {
         $0.leading.trailing.equalToSuperview()
         $0.top.equalTo(nickNameLabel.snp.bottom).offset(8)
         $0.height.equalTo(41)
      }
      
      nickNameTextField.snp.makeConstraints {
         $0.centerY.equalToSuperview()
         $0.leading.equalToSuperview().offset(8)
         $0.trailing.equalToSuperview().offset(-8)
      }
      
      nicknameDuplicateCheckLabel.snp.makeConstraints {
         $0.top.equalTo(textFieldContainer.snp.bottom).offset(5)
         $0.leading.equalToSuperview().offset(8)
         //         $0.width.equalTo(150)
         $0.height.equalTo(15)
      }
      
      myJobLabel.snp.makeConstraints {
         $0.top.equalTo(nicknameDuplicateCheckLabel.snp.bottom).offset(18)
         $0.leading.equalToSuperview().offset(8)
         $0.height.equalTo(21)
      }
      
      jobButtonsStackView.snp.makeConstraints {
         $0.top.equalTo(myJobLabel.snp.bottom).offset(8)
         $0.leading.trailing.equalToSuperview()
         $0.height.equalTo(41)
      }
      
      nextButton.snp.makeConstraints {
         $0.top.equalTo(jobButtonsStackView.snp.bottom).offset(18)
         $0.leading.trailing.equalToSuperview()
         $0.height.equalTo(41)
      }
   }
   
   private func postEditMyProfile() {
      if let token = self.keychain.get("accessToken") {
         switch activeViewType {
            
         case .FirstLogin:
            let checkFirstlogin = true
            MyProfileAPI.shared.postEditMyProfile(token: token, requestBody: editMyProfileBody, checkFirstlogin: checkFirstlogin) { result in
               switch result {
               case .success(let data):
                  if let data = data as? EditMyProfileDTO {
                     self.keychain.set(data.data.picture, forKey: "currentUserProfileImage")
                     self.keychain.set(data.data.nickName, forKey: "currentUserNickName")
                     self.keychain.set(data.data.occupation, forKey: "currentUserOccupation")
                     self.keychain.set(data.data.email, forKey: "currentUserEmail")
                     
                     self.postFcmToken()
                     print("üçéüçéüçéüçéüçéüçéüçécheckFirstlogin true / postFcmToken ÏÑ±Í≥µüçéüçéüçéüçéüçéüçéüçéüçéüçé")
                     self.dismiss(animated: true) {
                        let loginViewController = LoginViewController()
                        if let windowScene = UIApplication.shared.connectedScenes.first as? UIWindowScene,
                           let delegate = windowScene.delegate as? SceneDelegate,
                           let window = delegate.window {
                           window.rootViewController = loginViewController
                           window.makeKeyAndVisible()
                           let alertVC = EditGithubModalViewController()
                           alertVC.activeModalType = .FirstLogin
                           loginViewController.present(alertVC, animated: true, completion: nil)
                        }
                     }
                  }
               case .requestErr(let message):
                  print("Error : \(message)")
               case .pathErr, .serverErr, .networkFail:
                  print("another Error")
               default:
                  break
               }
            }
            
         case .NotFirstLogin:
            let checkFirstlogin = false
            MyProfileAPI.shared.postEditMyProfile(token: token, requestBody: editMyProfileBody, checkFirstlogin: checkFirstlogin) { result in
               switch result {
               case .success(_):
                  DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
                     self.showAlert(title: "ÌîÑÎ°úÌïÑ ÏàòÏ†ïÏùÑ ÏôÑÎ£åÌïòÏòÄÏäµÎãàÎã§",
                                    confirmButtonName: "ÌôïÏù∏",
                                    confirmButtonCompletion: { [self] in
                        self.profileUpdateDelegate?.didUpdateProfile()
                        self.dismiss(animated: true)
                     })
                  }
                  
                  print("NotFirstLogin ÌÉÄÏûÖ / checkFirstlogin false / ÌîÑÎ°úÌïÑÏàòÏ†ï ÏÑ±Í≥µÍ≥µ")
               case .requestErr(let message):
                  print("Error : \(message)")
               case .pathErr, .serverErr, .networkFail:
                  print("another Error")
               default:
                  break
               }
            }
         }
      }
   }
   
//   func getTopViewController() -> UIViewController? {
//      if var topController = UIApplication.shared.keyWindow?.rootViewController {
//         while let presentedViewController = topController.presentedViewController {
//            topController = presentedViewController
//         }
//         return topController
//      }
//      return nil
//   }
   
   func postFcmToken() {
      print("üî•")
      
      guard let token = self.keychain.get("accessToken") else {
         print("No accessToken found in keychain.")
         return
      }
      guard let fcmToken = keychain.get("FcmToken") else {return print("postFcmToken ÏïàÏóê FcmToken ÏÑ§Ï†ï ÏóêÎü¨")}
      
      NotificationAPI.shared.postFcmToken(token: token, requestBody: FcmTokenRequestBody(fcmToken: fcmToken)) { result in
         switch result {
         case .success(_):
            print("FcmToken Î≥¥ÎÇ¥Í∏∞ ÏÑ±Í≥µ")
            
         case .requestErr(let message):
            // ÏöîÏ≤≠ ÏóêÎü¨Ïù∏ Í≤ΩÏö∞
            print("Error : \(message)")
            if (message as AnyObject).contains("401") {
               // ÎßåÎ£åÎêú ÌÜ†ÌÅ∞ÏúºÎ°ú Ïù∏Ìï¥ ÏöîÏ≤≠ ÏóêÎü¨Í∞Ä Î∞úÏÉùÌïú Í≤ΩÏö∞
            }
            
         case .pathErr, .serverErr, .networkFail:
            // Îã§Î•∏ Ï¢ÖÎ•òÏùò ÏóêÎü¨Ïù∏ Í≤ΩÏö∞
            print("another Error")
         default:
            break
         }
      }
   }
   
   
   
   private func returnEditMyProfileUIHeight(type: String) -> CGFloat {
      if type == "First" {
         return 300.0
      }
      else {
         return 520
      }
   }
   
   //Ïó¨Í∏∞
   internal func textFieldDidEndEditing(_ textField: UITextField) {
      if let text = textField.text {
         print("ÏÇ¨Ïö©ÏûêÍ∞Ä ÏûÖÎ†•Ìïú ÌÖçÏä§Ìä∏: \(text)")
         if text == initialUserName {
            nickNameDuplicateFlag = true
            nicknameValidity = true
            editFlag = true
            DispatchQueue.main.async {
               self.nicknameDuplicateCheckLabel.text = "ÏÇ¨Ïö© Í∞ÄÎä•Ìïú ÎãâÎÑ§ÏûÑÏûÖÎãàÎã§."
            }
         } else {
            
            // Ï†ïÍ∑ú ÌëúÌòÑÏãùÏùÑ ÏÇ¨Ïö©ÌïòÏó¨ ÏòÅÏñ¥, ÌïúÍ∏Ä, Ïà´ÏûêÎßåÏùÑ ÌóàÏö©ÌïòÍ≥†, ÌïúÍ∏Ä ÏûêÏÜåÎ°ú ÎÇòÎàÑÏñ¥ÏßÑ ÏûÖÎ†•ÏùÑ ÌóàÏö©ÌïòÏßÄ ÏïäÎäîÏßÄ ÌôïÏù∏Ìï©ÎãàÎã§.
            let regex = "^[a-zA-Z0-9Í∞Ä-Ìû£]{1,8}$"
            let test = NSPredicate(format:"SELF MATCHES %@", regex)
            let result = test.evaluate(with: text)
            
            if !result {
               DispatchQueue.main.async {
                  self.showAlert(title: "ÎãâÎÑ§ÏûÑ ÏöîÍ±¥Ïù¥ Ï∂©Ï°±ÎêòÏßÄ Î™ªÌïòÏòÄÏäµÎãàÎã§",
                                 message: "1. ÌäπÏàòÎ¨∏ÏûêÎäî ÏûÖÎ†•Ïù¥ Î∂àÍ∞ÄÎä•Ìï©ÎãàÎã§.\n2. ÎãâÎÑ§ÏûÑ Í∏∏Ïù¥ Í∑úÏ†ïÏùÄ 1Í∏ÄÏûê Ïù¥ÏÉÅ 8Í∏ÄÏûê Ïù¥ÌïòÏûÖÎãàÎã§.\n3. '„Öã„Öó„Öç„Ö°„Ñπ„Öó'ÏôÄ Í∞ôÏù¥ ÌïúÍ∏Ä ÏûêÏÜå ÏûÖÎ†•ÏùÄ Î∂àÍ∞ÄÎä•Ìï©ÎãàÎã§.," ,
                                 confirmButtonName: "ÌôïÏù∏",
                                 confirmButtonCompletion: { [self] in
                     nicknameValidity = false
                     nicknameDuplicateCheckLabel.text = "ÏÇ¨Ïö©Ìï† Ïàò ÏóÜÎäî ÎãâÎÑ§ÏûÑÏûÖÎãàÎã§." })
               }
            } else {
               nicknameValidity = true
               getNickNameDuplication(nickname: text)
            }
         }
      }
      updateButtonState(type: "First")
   }
   
   internal func textFieldShouldReturn(_ textField: UITextField) -> Bool {
      textField.resignFirstResponder()
      return true
   }
   
   override func setUpKeyboard() {
      NotificationCenter.default.addObserver(self, selector: #selector(keyboardWillShow), name: UIResponder.keyboardWillShowNotification, object: nil)
      NotificationCenter.default.addObserver(self, selector: #selector(keyboardWillHide), name: UIResponder.keyboardWillHideNotification, object: nil)
   }
   
   deinit {
      NotificationCenter.default.removeObserver(self, name: UIResponder.keyboardWillShowNotification, object: nil)
      NotificationCenter.default.removeObserver(self, name: UIResponder.keyboardWillHideNotification, object: nil)
   }
   
   func addLanguageButtonsForJobType(jobType: String) {
      let jobTypeTechnologies = [
         "Frontend": ["React.js", "Vue.js", "Angular.js", "TypeScript"],
         "Backend": ["Spring", "Django", "Flask", "Node.js", "Go"],
         "Mobile": ["SwiftUI", "UIKit", "Flutter", "Kotlin", "Java", "RN"],
         "AI": ["TensorFlow", "Keras", "PyTorch"]
      ]
      DispatchQueue.main.async { [self] in
         guard let technologies = jobTypeTechnologies[jobType] else { return }
         languageStackView = UIStackView().then { stackView in
            stackView.axis = .horizontal
            stackView.distribution = .fillEqually
            stackView.spacing = 11
            
            for technology in technologies {
               stackView.addArrangedSubview(createButton(withTitle: technology))
               
            }
         }
         
         guard let stackView = languageStackView else { return print("languageStackView failed") }
         
         container.addSubviews(languageUsedLabel, languageCount, stackView)
         
         nextButton.removeFromSuperview()
         languageUsedLabel.snp.makeConstraints {
            $0.top.equalTo(jobButtonsStackView.snp.bottom).offset(18)
            $0.leading.equalToSuperview().offset(8)
            $0.height.equalTo(21)
         }
         
         languageCount.snp.makeConstraints {
            $0.leading.equalTo(languageUsedLabel.snp.trailing).offset(3)
            $0.bottom.equalTo(languageUsedLabel)
            $0.height.equalTo(14)
         }
         
         stackView.snp.makeConstraints {
            $0.top.equalTo(languageUsedLabel.snp.bottom).offset(8)
            $0.leading.trailing.equalToSuperview()
            $0.height.equalTo(41)
         }
      }
   }
   
   @objc func handleJobButtonSelection(_ sender: UIButton) {
      print("handleJobButtonSelection")
      for subview in jobButtonsStackView.arrangedSubviews {
         if let button = subview as? UIButton {
            button.isSelected = false
            button.layer.backgroundColor = UIColor.G1().cgColor
         }
      }
      selectedJob = sender.currentTitle
      isJobsButtonTap = true
      sender.isSelected = true
      sender.layer.backgroundColor = UIColor.P7().cgColor
      updateButtonState(type: "First")
   }
   
   @objc func handleLanguageButtonSelection(_ sender: UIButton) {
      DispatchQueue.main.async { [self] in
         print("selectedLanguageButtons.count :",selectedLanguageButtons.count)
         
         // ÏÑ†ÌÉùÌïú Ïñ∏Ïñ¥ Î≤ÑÌäºÏù¥ 2Í∞ú ÎØ∏ÎßåÏùº Îïå,
         if selectedLanguageButtons.count < 2 {
            
            // ÏÑ†ÌÉùÌïú Î≤ÑÌäºÏù¥ selectedLanguageButtonsÏóê Ïù¥ÎØ∏ ÏûàÏùÑ Îïå
            if selectedLanguageButtons.contains(sender) {
               print("ÏßÄÍ∏à 2Í∞ú ÎØ∏ÎßåÏù∏ ÏÉÅÌô©, selectedLanguageButtonsÏóê \(sender) ÏûàÏùå!!!")
               var index = 0
               for i in 0..<2 {
                  if selectedLanguageButtons[i] == sender {
                     selectedLanguageButtons[i].isSelected = false
                     selectedLanguageButtons[i].layer.backgroundColor = UIColor.G1().cgColor
                     selectedLanguageButtons.remove(at: i)
                     break
                  }
               }
            }
            // ÏÑ†ÌÉùÌïú Î≤ÑÌäºÏù¥ selectedLanguageButtonsÏóê ÏóÜÏùÑ Îïå
            else {
               sender.isSelected = true
               sender.layer.backgroundColor = UIColor.P7().cgColor
               selectedLanguageButtons.append(sender)
            }
            
            languageCount.text = "(\(selectedLanguageButtons.count)/2)"
         }
         
         // ÏÑ†ÌÉùÌïú Ïñ∏Ïñ¥ Î≤ÑÌäºÏù¥ 2Í∞ú Ïù¥ÏÉÅÏùº Îïå,
         else {
            if selectedLanguageButtons.contains(sender) {
               print("ÏßÄÍ∏à 2Í∞ú Ïù¥ÏÉÅÏù∏ ÏÉÅÌô©, selectedLanguageButtonsÏóê \(sender) ÏûàÏùå!!!")
               for i in 0..<2 {
                  if selectedLanguageButtons[i] == sender {
                     selectedLanguageButtons[i].isSelected = false
                     selectedLanguageButtons[i].layer.backgroundColor = UIColor.G1().cgColor
                     selectedLanguageButtons.remove(at: i)
                     break
                  }
               }
            }
            else {
               // ÏÑ†ÌÉùÎêú Î≤ÑÌäºÏù¥ Ïù¥ÎØ∏ 2Í∞úÏùº Îïå
               let firstButton = selectedLanguageButtons.removeFirst()   // Ï≤´ Î≤àÏß∏Î°ú ÏÑ†ÌÉùÎêú Î≤ÑÌäºÏùÑ Ï†úÍ±∞
               firstButton.isSelected = false
               firstButton.layer.backgroundColor = UIColor.G1().cgColor
               
               sender.isSelected = true
               sender.layer.backgroundColor = UIColor.P7().cgColor
               selectedLanguageButtons.append(sender)   // ÏÉàÎ°ú ÏÑ†ÌÉùÎêú Î≤ÑÌäºÏùÑ Ï∂îÍ∞Ä
            }
            languageCount.text = "(\(selectedLanguageButtons.count)/2)"
            
         }
         updateButtonState(type: "End")
      }
   }
   
   @objc func handleCareerButtonSelection(_ sender: UIButton) {
      guard let careerStackView = careerStackView else {return print("careerStackView error")}
      for subview in careerStackView.arrangedSubviews {
         if let button = subview as? UIButton {
            button.isSelected = false
            button.layer.backgroundColor = UIColor.G1().cgColor
         }
      }
      sender.isSelected = true
      sender.layer.backgroundColor = UIColor.P7().cgColor
      selectedCareer = sender.currentTitle
      updateButtonState(type: "End")
   }
   
   
   func updateButtonState(type: String) {
      if type == "First" {
         var isTextFieldNotEmpty = nickNameTextField.text?.isEmpty == false
         let isSelectedJobNotEmpty = selectedJob?.isEmpty == false
         DispatchQueue.main.async { [self] in
            if isTextFieldNotEmpty && isSelectedJobNotEmpty {
               nextButton.backgroundColor = UIColor.P2()
               editFlag = true
            } else {
               nextButton.backgroundColor = .gray
               editFlag = false
            }
         }
      } else {
         let isSelectedButtonsNotEmpty = selectedLanguageButtons.isEmpty == false
         let isSelectedCareerNotEmpty = selectedCareer?.isEmpty == false
         DispatchQueue.main.async { [self] in
            if isSelectedButtonsNotEmpty && isSelectedCareerNotEmpty {
               doneButton.backgroundColor = UIColor.P2()
               let languageArr = selectedLanguageButtons.map { $0.currentTitle ?? "" }
               editMyProfileBody.language = languageArr.joined(separator: ",")
               editMyProfileBody.career = convertCareerToInt(selectedCareer: selectedCareer ?? "")
               doneButton.isEnabled = true
            } else {
               doneButton.backgroundColor = UIColor.G1()
               doneButton.isEnabled = false
            }
         }
      }
   }
   
   func convertCareerToInt(selectedCareer: String) -> Int {
      if selectedCareer == "Ïã†ÏûÖ" {
         return 1
      } else if selectedCareer == "3ÎÖÑ ÎØ∏Îßå" {
         return 2
      } else if selectedCareer == "3ÎÖÑ Ïù¥ÏÉÅ" {
         return 3
      } else if selectedCareer == "5ÎÖÑ Ïù¥ÏÉÅ" {
         return 4
      } else if selectedCareer == "10ÎÖÑ Ïù¥ÏÉÅ" {
         return 5
      } else {
         return 20
      }
   }
   
   
   
   @objc func didTapNextButton(jobType: String) {
      editMyProfileBody.nickName = nickNameTextField.text ?? ""
      editMyProfileBody.occupation = selectedJob ?? ""
      nickNameTextField.isEnabled = false
      
      DispatchQueue.main.async { [self] in
         nextButton.isHidden = true
         nickNameLabel.textColor = UIColor.gray
         nickNameTextField.textColor = UIColor.gray
         myJobLabel.textColor = UIColor.gray
         jobButtonsStackView.arrangedSubviews.forEach { view in
            if let button = view as? UIButton {
               button.isEnabled = false
               if button.isSelected == true {
                  button.setTitleColor(UIColor(hex: "#5D5BC1"), for: .normal)
               }
            }
         }
         sheetPresentationController?.animateChanges { [self] in
            self.sheetPresentationController?.detents = [.custom {context in
               return self.returnEditMyProfileUIHeight(type: "Secound")
            }]
         }
         
         addLanguageButtonsForJobType(jobType: jobType)
         addCareerButtons()
         addDoneButton()
      }
   }
   
   
   
   func addCareerButtons() {
      careerStackView = UIStackView().then { stackView in
         stackView.axis = .horizontal
         stackView.distribution = .fillEqually
         stackView.spacing = 11
         let careerType = ["Ïã†ÏûÖ", "3ÎÖÑ ÎØ∏Îßå", "3ÎÖÑ Ïù¥ÏÉÅ", "5ÎÖÑ Ïù¥ÏÉÅ", "10ÎÖÑ Ïù¥ÏÉÅ"]
         
         for career in careerType {
            stackView.addArrangedSubview(createButton(withTitle: career))
         }
      }
      
      DispatchQueue.main.async { [self] in
         guard let stackView = careerStackView else { return print("careerStackView failed") }
         if let languageStackView = languageStackView {
            container.addSubviews(careerLabel, stackView)
            
            careerLabel.snp.makeConstraints {
               $0.top.equalTo(languageStackView.snp.bottom).offset(18)
               $0.leading.equalToSuperview().offset(8)
               $0.height.equalTo(21)
            }
            
            stackView.snp.makeConstraints {
               $0.top.equalTo(careerLabel.snp.bottom).offset(8)
               $0.leading.trailing.equalToSuperview()
               $0.height.equalTo(41)
            }
         } else {
            // languageStackViewÍ∞Ä nilÏùº ÎïåÏùò Ï≤òÎ¶¨Î•º Ïó¨Í∏∞Ïóê ÏûëÏÑ±Ìï©ÎãàÎã§.
         }
      }
   }
   
   func addDoneButton() {
      DispatchQueue.main.async { [self] in
         container.addSubview(doneButton)
         
         doneButton.snp.makeConstraints {
            $0.bottom.equalToSuperview().offset(-27)
            $0.leading.equalToSuperview().offset(16)
            $0.trailing.equalToSuperview().offset(-16)
            $0.height.equalTo(41)
         }
         updateButtonState(type: "didTapNextButton")
      }
   }
   
   
   
   //Ïñò ÌôúÏö©ÌïòÍ∏∞
   func createButton(withTitle title: String) -> UIButton {
      let button = UIButton()
      button.setTitle(title, for: .normal)
      button.titleLabel?.setPretendardFont(text: title, size: 13, weight: .regular, letterSpacing: 1.23)
      button.layer.backgroundColor = UIColor.G1().cgColor
      button.layer.cornerRadius = 10
      button.setTitleColor(UIColor.G4(), for: .normal)
      button.setTitleColor(UIColor.P5(), for: .selected)
      button.titleEdgeInsets = UIEdgeInsets(top: 0, left: 3, bottom: 0, right: 3) // Ïó¨Í∏∞ÏóêÏÑú Ìå®Îî©ÏùÑ ÏÑ§Ï†ïÌï©ÎãàÎã§. ÏõêÌïòÎäî Í∞íÏúºÎ°ú Ï°∞Ï†àÌïòÏÑ∏Ïöî.
      if ["Frontend", "Backend", "Mobile", "AI"].contains(title) {
         button.addTarget(self, action: #selector(handleJobButtonSelection(_:)), for: .touchUpInside)
      } else if ["Ïã†ÏûÖ", "3ÎÖÑ ÎØ∏Îßå", "3ÎÖÑ Ïù¥ÏÉÅ", "5ÎÖÑ Ïù¥ÏÉÅ", "10ÎÖÑ Ïù¥ÏÉÅ"].contains(title) {
         button.addTarget(self, action: #selector(handleCareerButtonSelection(_:)), for: .touchUpInside)
      } else {
         button.addTarget(self, action: #selector(handleLanguageButtonSelection(_:)), for: .touchUpInside)
      }
      
      if beforeEditMyProfileData?.language.contains(title) == true ||
            beforeEditMyProfileData?.career == convertCareerToInt(selectedCareer: title) || beforeEditMyProfileData?.occupation.contains(title) == true {
         if beforeEditMyProfileData?.language.contains(title) == true {
            selectedLanguageButtons.append(button)
         } else if beforeEditMyProfileData?.career == convertCareerToInt(selectedCareer: title) {
            selectedCareer = title
         } else {
            selectedJob = title
         }
         button.isSelected = true
         button.layer.backgroundColor = UIColor.P7().cgColor
      }
      
      return button
   }
   
   private func getNickNameDuplication(nickname: String) {
      if let token = self.keychain.get("accessToken") {
         print("ÌòÑÏû¨ nickname : \(nickname)")
         MyProfileAPI.shared.getNickNameDuplication(token: token, nickname: nickname) { result in
            print("Result: \(result)")
            switch result {
            case .success(let data):
               print("üåäüåäüåäüåäüåäüåäüåäüåäüåäüåäüåäuccessüåäüåäüåäüåäüåäüåäüåäüåäüåäüåäüåä")
               if let data = data as? getNickNameDuplicationDTO {
                  self.nickNameDuplicateFlag = data.data
                  DispatchQueue.main.async {
                     self.nicknameDuplicateCheckLabel.text = data.message
                  }
               } else {
                  print("Failed to decode the response.")
               }
               
            case .requestErr(let message):
               print("Error : \(message)")
            case .pathErr, .serverErr, .networkFail:
               print("another Error")
            default:
               break
            }
         }
      }
   }
   
   @objc func didDoneButton() {
      postEditMyProfile()
   }
   
   
   @objc func didNextButtonAlert() {
      if readyForNextButton == false {
         nickNameTextField.resignFirstResponder()
      } else {
         if editFlag == true && nickNameDuplicateFlag == true && nicknameValidity == true {
            didNext()
         }
         else {
            didError()
         }
         
      }
   }
   
   @objc private func didNext() {
      showAlert(title: "Îã§Ïùå ÏàòÏ†ïÏùÑ ÏßÑÌñâÌïòÏãúÍ≤†ÏäµÎãàÍπå?",
                message: "Ïù¥ÌõÑ Ïù¥Ï†Ñ ÎÇ¥Ïö©ÏùÄ ÏàòÏ†ïÌïòÏã§ Ïàò ÏóÜÏäµÎãàÎã§" ,
                cancelButtonName: "Ï∑®ÏÜå",
                confirmButtonName: "ÌôïÏù∏",
                confirmButtonCompletion: { [self] in
         didTapNextButton(jobType: selectedJob ?? "")
      })
   }
   
   @objc private func didError() {
      showAlert(title: "Î™®Îì† ÌïÑÎìúÍ∞Ä Ïú†Ìö®ÌïúÏßÄ ÌôïÏù∏ Î∞è ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî",
                confirmButtonName: "ÌôïÏù∏")
   }
   
   func faileEditProfile() {
      showAlert(title: "ÌîÑÎ°úÌïÑ ÏàòÏ†ïÏùÑ Ïã§Ìå®ÌïòÏòÄÏäµÎãàÎã§",
                confirmButtonName: "ÌôïÏù∏",
                confirmButtonCompletion: { [self] in
         self.dismiss(animated: true, completion: nil)
      })
   }
   
   @objc func keyboardWillShow(notification: NSNotification) {
      if ((notification.userInfo?[UIResponder.keyboardFrameEndUserInfoKey] as? NSValue)?.cgRectValue) != nil {
         readyForNextButton = false
         UIView.animate(withDuration: 0.3) {
            self.view.layoutIfNeeded()
         }
      }
   }
   
   @objc func keyboardWillHide(notification: NSNotification) {
      readyForNextButton = true
      UIView.animate(withDuration: 0.3) {
         self.view.layoutIfNeeded()
      }
   }
   
}
